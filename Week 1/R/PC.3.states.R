#
# State PC Example. Start by calling princomp() with nothing else.
#
state.prx <- prcomp (state.x77)
plot (state.prx)
round (state.prx$rot, 3) # Show loadings
# What's going on here?

# Compute variance for each column; also, round and sort to make
# them easier to see
#
sort (round (apply (state.x77, 2, var), 1), decreasing = TRUE)
#
# The variability is an order of magnitude bigger for Area than for anything
# else. So if you want to measure variability, you just focus on Area.
#
# That's why it makes sense to scale. Let's do that. 
#

state.pr <- prcomp (state.x77, scale=T) 
#
# Since we're scaling, each column has variance 1 and the sum of the 
# column variances is 8. Therefore the sum of the varinaces of the score
# columns is also 8, as shown. 
#
sum (apply (state.pr$x, 2, var)) # This is exactly 8.
#
# In the (scaled) data, each column has SD 1. In the scores, some columns have
# SDs bigger than 1, and some smaller.
#
state.pr$sdev

plot (state.pr) # Screeplot; how many components to keep?
summary (state.pr) # Perhaps 5?

#
# Let's use Nevada as an example
#
NV <- state.x77["Nevada",]
#
# Center and scale.
# 
NV.std <- (NV - state.pr$center) / state.pr$scale
#
# Now transform into scores.
#
NV.std %*% state.pr$rotation
#
# These are exactly what we expect...
#
(NV.scores <- state.pr$x["Nevada",])
#
# Just to make sure, let's go backward. We start with the scores,
# convert using the transpose of loadings, and then un-standardize.
#
(NV.scores %*% t(state.pr$rotation)) * state.pr$scale + state.pr$center
#
# Now comes the fun part. If we only kept 5 of the original columnns, we
# would probably lose some valuable information. But if we keep 5 of the
# PC scores, we keep 93% of the original variability. That might be a pretty
# god approximation.

(NV.scores[1:5] %*% t(state.pr$rotation[,1:5])) * state.pr$scale + state.pr$center
#
# Not perfect, but not too terrible, either.
#
# Technical note: if you wanted to do all the states at once, you will 
# need to remember that when R replicates elements of a vector to match
# up with a data frame, it does so in column order. So (state.x77 - 
# state.pr$center) doesn't work: the 8 entries in state.pr$center get 
# subtracted from the "Population" column of the first 8 states, and then
# the next 8 states, and so on. Instead you need something like this:
#
s77.scaled <- (state.x77 - rep (state.pr$center, each=nrow(state.x77))) / rep (state.pr$scale, each=nrow(state.x77))

s77.scores <- s77.scaled %*% state.pr$rotation
#
# Do these match the scores generated by prcomp()?
#
range (s77.scores - state.pr$x)# Yes indeed.
#
# Now go back to the original dat
s77.newdata <- (s77.scores %*% t(state.pr$rotation)) * rep (state.pr$scale, each=50) + rep (state.pr$center, each=50)
range (s77.newdata - state.x77) # floating-point error
#
# Using 5 PCs we can produce a matrix of "pretty good" approximations. 
#
s77.newdata5 <- (s77.scores[,1:5] %*% t(state.pr$rotation[,1:5])) * rep (state.pr$scale, each=50) + rep (state.pr$center, each=50)
#
# How does this new approximate data correlate with the old, true data?
#
cors <- numeric (8)
for (i in 1:8)
    cors[i] <- cor (s77.newdata5[,i], state.x77[,i])
cors # not bad


